// src/engine.rs
use std::collections::HashMap;
use rust_decimal::Decimal;
use rust_decimal_macros::dec;
use uuid::Uuid;
use chrono::NaiveDate;

use crate::{
    error::{LedgerError, Strictness},
    types::{AccountType, AccountKind},
    account::Account,
    posting::Posting,
    transaction::Transaction,
    trial_balance::{AccountBalance, TrialBalance},
};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct LedgerEngine {
    chart_of_accounts: HashMap<Uuid, Account>,
    account_balances: HashMap<Uuid, Decimal>, // O(1) balance lookup
    general_ledger: Vec<Transaction>,
    strictness: Strictness,
}

impl LedgerEngine {
    pub fn new() -> Self {
        Self {
            chart_of_accounts: HashMap::new(),
            account_balances: HashMap::new(),
            general_ledger: Vec::new(),
            strictness: Strictness::default(),
        }
    }

    pub fn with_strictness(mut self, strictness: Strictness) -> Self {
        self.strictness = strictness;
        self
    }

    pub fn add_account(pub fn add_account(&mut self, account: Account) {mut self, account: Account) { let id = account.id;
        self.chart_of_accounts.insert(id, account);
        self.account_balances.entry(id).or_insert(dec!(0));
    }

    pub fn record_transaction(&mut self, tx: Transaction) -> Result<(), LedgerError> {
        tx.validate()?;

        // Validate all referenced accounts exist
        for p in &tx.postings {
            if !self.chart_of_accounts.contains_key(&p.account_id) {
                return Err(LedgerError::AccountNotFound(p.account_id));
            }
        }

        // Strict mode: simulate balances and reject abnormal outcomes
        if self.strictness == Strictness::Strict {
            for p in &tx.postings {
                let account = &self.chart_of_accounts[&p.account_id];
                let new_balance = self.account_balances[&p.account_id] + p.amount;
                let expected = account.natural_balance();
                let actual = if new_balance.is_sign_positive() || new_balance.is_zero() {
                    AccountKind::Debit
                } else {
                    AccountKind::Credit
                };

                if expected != actual && !new_balance.is_zero() {
                    return Err(LedgerError::AbnormalBalance {
                        account_id: account.id,
                        account_name: account.name.clone(),
                        expected: expected.to_string(),
                        actual: actual.to_string(),
                    });
                }
            }
        }

        // Commit: update balances & append tx
        for p in &tx.postings {
            *self.account_balances.get_mut(&p.account_id).unwrap() += p.amount;
        }
        self.general_ledger.push(tx);

        Ok(())
    }

    pub fn get_account_balance(&self, account_id: &Uuid) -> Decimal {
        *self.account_balances.get(account_id).unwrap_or(&dec!(0))
    }

    pub fn recompute_balances(&mut self) {
        self.account_balances.values_mut().for_each(|v| *v = dec!(0));
        for tx in &self.general_ledger {
            for p in &tx.postings {
                *self.account_balances.get_mut(&p.account_id).unwrap() += p.amount;
            }
        }
    }

    pub fn generate_trial_balance(&self) -> TrialBalance {
        let mut accounts = Vec::new();
        let mut total_debits = dec!(0);
        let mut total_credits = dec!(0);

        for (id, account) in &self.chart_of_accounts {
            let net = self.get_account_balance(id);
            let (debit, credit) = if net >= dec!(0) { (net, dec!(0)) } else { (dec!(0), -net) };
            let expected = account.natural_balance();
            let actual = if net.is_sign_positive() || net.is_zero() { AccountKind::Debit } else { AccountKind::Credit };
            let is_abnormal = net != dec!(0) && expected != actual;

            accounts.push(AccountBalance {
                account_id: *id,
                account_name: account.name.clone(),
                account_type: account.account_type.clone(),
                debit,
                credit,
                net,
                is_abnormal,
            });

            total_debits += debit;
            total_credits += credit;
        }

        accounts.sort_by_key(|ab| ab.account_id);

        TrialBalance {
            accounts,
            total_debits,
            total_credits,
            is_balanced: total_debits == total_credits,
        }
    }

    pub fn generate_and_post_closing_entries(
        &mut self,
        closing_date: NaiveDate,
        retained_earnings_id: Uuid,
    ) -> Result<Vec<Uuid>, LedgerError> {
        if !self.chart_of_accounts.contains_key(&retained_earnings_id) {
            return Err(LedgerError::RetainedEarningsAccountNotFound(retained_earnings_id));
        }

        let mut closing_postings = Vec::new();
        let mut net_income = dec!(0);

        // Zero out temporary accounts
        for (id, account) in &self.chart_of_accounts {
            if !account.account_type.is_temporary() {
                continue;
            }
            let balance = self.get_account_balance(id);
            if balance.is_zero() {
                continue;
            }

            match account.account_type {
                AccountType::Revenue => {
                    closing_postings.push(Posting::debit(*id, balance.abs()));
                    net_income += balance.abs();
                }
                AccountType::Expense => {
                    closing_postings.push(Posting::credit(*id, balance.abs()));
                    net_income -= balance.abs();
                }
                _ => unreachable!(),
            }
        }

        if !net_income.is_zero() {
            if net_income.is_sign_positive() {
                closing_postings.push(Posting::credit(retained_earnings_id, net_income));
            } else {
                closing_postings.push(Posting::debit(retained_earnings_id, -net_income));
            }
        }

        if closing_postings.is_empty() {
            return Ok(vec![]);
        }

        let tx_id = Uuid::new_v4();
        let _tx = Transaction::new(tx_id, closing_date, "Closing Entries")
            .with_closing()
            .with_metadata("period_end", closing_date.to_string());

        let closing_tx = Transaction {
            id: tx_id,
            date: closing_date,
            description: format!("Closing Entries for {}", closing_date),
            postings: closing_postings,
            is_closing_entry: true,
            is_reversing_entry: false,
            metadata: [("period_end".to_string(), closing_date.to_string())].into(),
        };

        self.record_transaction(closing_tx)?;
        Ok(vec![tx_id])
    }

    pub fn reverse_transaction(&mut self, tx_id: &Uuid) -> Result<Uuid, LedgerError> {
        let tx = self.general_ledger
            .iter()
            .find(|t| &t.id == tx_id)
            .ok_or(LedgerError::AccountNotFound(*tx_id))?; // misuse for TX not found

        let reversed = tx.postings
            .iter()
            .map(|p| Posting { account_id: p.account_id, amount: -p.amount })
            .collect();

        let rev_id = Uuid::new_v4();
        let _rev_tx = Transaction::new(rev_id, tx.date, format!("Reversal of {}", tx.id))
            .with_reversing();

        let _rev_tx = Transaction {
            id: rev_id,
            date: tx.date,
            description: format!("Reversal of {}", tx.id),
            postings: reversed,
            is_closing_entry: false,
            is_reversing_entry: true,
            metadata: [("reverses".to_string(), tx.id.to_string())].into(),
        };

        self.record_transaction(rev_tx)?;
        Ok(rev_id)
    }

    // --- Read-only accessors ---
    pub fn accounts(&self) -> &HashMap<Uuid, Account> {
        &self.chart_of_accounts
    }

    pub fn transactions(&self) -> &Vec<Transaction> {
        &self.general_ledger
    }
}